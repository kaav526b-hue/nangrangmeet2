// 전역 변수 설정 (Canvas 환경에서 제공됨)
const appId = 'nangrangmeet2'; // <<-- 리포지토리 이름을 앱 ID로 사용 (수정됨)

// ====================================================================
// 🚨🚨🚨 [필수] 이 부분을 사용자님의 Firebase 설정 정보로 반드시 교체하세요! 🚨🚨🚨
// GitHub Pages에서 Firebase 데이터베이스를 사용하려면 이 정보가 필요합니다.
// Firebase 콘솔 > 프로젝트 설정 > 웹 앱 설정 -> 스크립트에서 가져올 수 있습니다.
// ====================================================================
const firebaseConfig = {
    apiKey: "YOUR_API_KEY_HERE", 
    authDomain: "YOUR_AUTH_DOMAIN_HERE", 
    projectId: "YOUR_PROJECT_ID_HERE",
    storageBucket: "YOUR_STORAGE_BUCKET_HERE",
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID_HERE",
    appId: "YOUR_APP_ID_HERE"
};
// ====================================================================

const initialAuthToken = null; // GitHub Pages에서는 사용하지 않으므로 null로 설정

// 관리자 접근 비밀번호 (간단한 보안 장치, 실제로는 서버에서 처리해야 함)
const ADMIN_KEY = "018515"; 

// --------------------------------------------------------
// 🚨 이곳을 수정하여 참가자 닉네임 리스트를 변경하세요! (총 32명) 🚨
// --------------------------------------------------------
const FULL_PARTICIPANT_LIST = [
    { class: '햇님반', num: '01', name: '김민준' }, { class: '달님반', num: '01', name: '이서윤' },
    { class: '햇님반', num: '02', name: '박지훈' }, { class: '달님반', num: '02', name: '최아린' },
    { class: '햇님반', num: '03', name: '이도현' }, { class: '달님반', num: '03', name: '김예나' },
    { class: '햇님반', num: '04', name: '정우성' }, { class: '달님반', num: '04', name: '한지우' },
    { class: '햇님반', num: '05', name: '조승현' }, { class: '달님반', num: '05', name: '오하늘' },
    { class: '햇님반', num: '06', name: '윤재민' }, { class: '달님반', num: '06', name: '서은채' },
    { class: '햇님반', num: '07', name: '장혁진' }, { class: '달님반', num: '07', name: '고유진' },
    { class: '햇님반', num: '08', name: '송건우' }, { class: '달님반', num: '08', name: '문소희' },
    { class: '햇님반', num: '09', name: '강태양' }, { class: '달님반', num: '09', name: '임채원' },
    { class: '햇님반', num: '10', name: '신현우' }, { class: '달님반', num: '10', name: '배수민' },
    { class: '햇님반', num: '11', name: '황준서' }, { class: '달님반', num: '11', name: '류다인' },
    { class: '햇님반', num: '12', name: '전영호' }, { class: '달님반', num: '12', name: '민주아' },
    { class: '햇님반', num: '13', name: '오상민' }, { class: '달님반', num: '13', name: '공서영' },
    { class: '햇님반', num: '14', name: '변정수' }, { class: '달님반', num: '14', name: '육예진' },
    { class: '햇님반', num: '15', name: '양성재' }, { class: '달님반', num: '15', name: '주은서' },
    { class: '햇님반', num: '16', name: '유동훈' }, { class: '달님반', num: '16', name: '진혜리' }
];

// --------------------------------------------------------
// 0. Globals for Listener Management
// --------------------------------------------------------
let participantsUnsubscribe = null;
let matchesUnsubscribe = null;

let app;
let db;
let auth;
let currentUserId = null;
let currentUserNickname = '미정';
let currentRole = 'none';
let isAdminValidated = false; // 관리자 인증 성공 여부 플래그

// 데이터 상태
let participants = []; // Firestore에 등록된 참가자 (닉네임 등록 완료자)
let submissions = {}; // Key: userId, Value: {choice1, choice2, choice3}
let finalMatches = [];
let isMatchInProgress = false;

// --------------------------------------------------------
// 1. Firebase 초기화 및 인증
// --------------------------------------------------------
async function initializeFirebase() {
    try {
        // Firebase Config가 설정되었는지 확인
        if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes('YOUR_API_KEY_HERE')) {
            document.getElementById('system-status').textContent = '🚨 오류: Firebase 설정 정보가 누락되었습니다. index.html 파일의 firebaseConfig 부분을 수정해주세요.';
            console.error("Firebase Config Error: Configuration object is missing or invalid. Please update the firebaseConfig object in index.html with your actual Firebase project settings.");
            return; 
        }

        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        document.getElementById('system-status').textContent = '인증 및 데이터베이스 연결 중...';

        // 인증 처리 (GitHub Pages에서는 익명 인증만 사용)
        if (initialAuthToken) {
            await signInWithCustomToken(auth, initialAuthToken);
        } else {
            await signInAnonymously(auth);
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserId = user.uid;
                document.getElementById('user-id').textContent = currentUserId; 
                document.getElementById('system-status').textContent = '시스템 준비 완료. 역할을 선택하세요.';
                setupParticipant(currentUserId);
                startListeners(); // 인증 후 리스너 시작
            } else {
                console.error("인증 실패: 사용자 정보를 가져올 수 없습니다.");
                document.getElementById('system-status').textContent = '인증 실패';
            }
        });

    } catch (error) {
        console.error("Firebase 초기화 중 오류 발생:", error);
        document.getElementById('system-status').textContent = `오류: ${error.message}`;
    }
}

/**
 * 사용자가 처음 접속하거나 인증될 때 닉네임 설정 및 참가자 목록에 등록
 */
async function setupParticipant(userId) {
    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'participants', userId);

    try {
        const docSnap = await getDoc(docRef);
        const nicknamePattern = /^(햇님반|달님반)\s\d{2}\s.+$/; // 예: 햇님반 01 김개똥

        let userNeedsSetup = true;

        if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.nickname && nicknamePattern.test(data.nickname)) {
                // 유효한 형식의 닉네임이 이미 등록되어 있음
                currentUserNickname = data.nickname;
                userNeedsSetup = false;
            } else {
                // 닉네임이 있지만 형식이 유효하지 않음 (이전 임시 닉네임 등)
                currentUserNickname = '닉네임 재설정 필요';
            }
        }

        document.getElementById('user-nickname').textContent = currentUserNickname;
        
        // FIX: currentRole이 'none'이 아닐 때만 뷰 렌더링 함수 호출하여 중복 호출 방지
        if (currentRole === 'participant') {
            if (userNeedsSetup) {
                renderSetupForm(); // 참가자 모드이고 설정이 필요하면 폼 렌더링
            } else {
                 renderParticipantView(); // 참가자 모드이고 설정 완료 시 뷰 렌더링
            }
        }

    } catch (e) {
        console.error("참가자 설정 중 오류 발생:", e);
        showModal(`참가자 정보 로드 오류: ${e.message}`, false);
    }
}

/**
 * 닉네임 설정을 위한 폼 렌더링 (참가자 모드)
 */
function renderSetupForm() {
    const container = document.getElementById('mode-container');
    const classOptions = ['햇님반', '달님반'].map(c => `<option value="${c}">${c}</option>`).join('');
    const numOptions = Array.from({ length: 16 }, (_, i) => (i + 1).toString().padStart(2, '0'))
        .map(n => `<option value="${n}">${n}번</option>`).join('');

    container.innerHTML = `
        <div class="max-w-md mx-auto p-8 bg-purple-50 rounded-xl shadow-lg border border-purple-200 mt-6">
            <h2 class="text-2xl font-bold text-purple-800 mb-6 text-center">🏃 참가자 닉네임 등록 🏃</h2>
            <p class="text-sm text-gray-600 mb-6 text-center">자신의 그룹과 번호를 선택하면 이름이 자동 확정됩니다.</p>
            
            <form id="setup-form" onsubmit="submitSetupForm(event)" class="space-y-4">
                <div class="flex flex-col space-y-1">
                    <label for="setup-class" class="font-semibold text-gray-700">1. 그룹 선택</label>
                    <select id="setup-class" required onchange="updateCalculatedNickname()" class="w-full p-3 border border-purple-300 rounded-lg bg-white">
                        <option value="">-- 그룹을 선택하세요 --</option>
                        ${classOptions}
                    </select>
                </div>
                
                <div class="flex flex-col space-y-1">
                    <label for="setup-num" class="font-semibold text-gray-700">2. 번호 선택 (01~16)</label>
                    <select id="setup-num" required onchange="updateCalculatedNickname()" class="w-full p-3 border border-purple-300 rounded-lg bg-white">
                        <option value="">-- 번호를 선택하세요 --</option>
                        ${numOptions}
                    </select>
                </div>
                
                <div id="calculated-nickname" data-nickname="" class="mt-4 p-4 bg-white rounded-lg border-2 border-dashed border-blue-300 text-center">
                    <p class="text-gray-500">그룹과 번호를 모두 선택해주세요.</p>
                </div>

                <button type="submit" disabled class="w-full py-3 mt-6 text-white font-bold rounded-lg bg-purple-600 hover:bg-purple-700 transition shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">
                    닉네임 등록 및 참가 시작
                </button>

                <p id="setup-error" class="text-red-500 text-sm mt-3 text-center hidden"></p>
            </form>
        </div>
    `;

    // 초기 닉네임 업데이트 (옵션이 로드된 후 한 번 실행)
    updateCalculatedNickname();
}

/**
 * 그룹과 번호 선택에 따라 닉네임을 계산하고 표시합니다.
 */
function updateCalculatedNickname() {
    const groupSelect = document.getElementById('setup-class');
    const numSelect = document.getElementById('setup-num');
    const nicknameDisplay = document.getElementById('calculated-nickname');
    const submitButton = document.getElementById('setup-form').querySelector('button[type="submit"]');

    const selectedGroup = groupSelect.value;
    const selectedNum = numSelect.value;

    submitButton.disabled = true;
    nicknameDisplay.dataset.nickname = "";

    if (!selectedGroup || !selectedNum) {
        nicknameDisplay.innerHTML = `<p class="text-gray-500">그룹과 번호를 모두 선택해주세요.</p>`;
        return;
    }

    // Group과 Number에 매칭되는 Name을 찾습니다.
    const participant = FULL_PARTICIPANT_LIST.find(p => 
        p.class === selectedGroup && p.num === selectedNum
    );

    if (participant) {
        const calculatedNickname = `${participant.class} ${participant.num} ${participant.name}`;
        nicknameDisplay.innerHTML = `
            <p class="text-sm font-semibold text-gray-700">확정될 닉네임:</p>
            <p class="text-xl font-bold text-blue-600 mt-1">${calculatedNickname}</p>
        `;
        // 계산된 닉네임을 dataset에 저장하여 submit 함수에서 사용
        nicknameDisplay.dataset.nickname = calculatedNickname; 
        submitButton.disabled = false;
    } else {
        nicknameDisplay.innerHTML = `<p class="text-red-500 font-bold">오류: 해당 그룹/번호 조합을 찾을 수 없습니다.</p>`;
        submitButton.disabled = true;
    }
}

/**
 * 닉네임 설정 폼 제출 처리
 */
async function submitSetupForm(event) {
    event.preventDefault();
    const form = event.target;
    const errorElement = document.getElementById('setup-error');
    errorElement.classList.add('hidden');

    const nicknameDisplay = document.getElementById('calculated-nickname');
    const newNickname = nicknameDisplay.dataset.nickname;

    if (!newNickname) {
        errorElement.textContent = '그룹과 번호를 선택하여 닉네임을 확정해주세요.';
        errorElement.classList.remove('hidden');
        return;
    }

    // 1. 중복된 닉네임이 이미 존재하는지 확인 (닉네임 유효성은 updateCalculatedNickname에서 이미 확인됨)
    const isNicknameTaken = participants.some(p => p.nickname === newNickname);
    if (isNicknameTaken) {
        errorElement.textContent = `이미 '${newNickname}' 닉네임으로 등록된 참가자가 있습니다. 다른 번호를 선택해주세요.`;
        errorElement.classList.remove('hidden');
        return;
    }

    showModal('닉네임을 등록하는 중...', true);

    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'participants', currentUserId);

    try {
        await setDoc(docRef, {
            nickname: newNickname,
            submitted: false,
            choice1: null, // 이제 Nickname String이 저장됨
            choice2: null, // 이제 Nickname String이 저장됨
            choice3: null, // 이제 Nickname String이 저장됨
            finalMatch: null,
            timestamp: Date.now()
        }, { merge: true });

        currentUserNickname = newNickname;
        document.getElementById('user-nickname').textContent = newNickname;

        hideModal();
        showModal('✅ 닉네임 등록 완료! 최종 선택을 진행하세요.', false);
        renderParticipantView(); // 선택 폼 렌더링
    } catch (e) {
        console.error("닉네임 등록 오류:", e);
        showModal(`등록 실패: ${e.message}`, false);
    }
}


// --------------------------------------------------------
// 2. 실시간 데이터 리스너
// --------------------------------------------------------
function startListeners() {
    // FIX: 기존 리스너 해제 (중복 구독 및 내부 상태 오류 방지)
    if (participantsUnsubscribe) {
        participantsUnsubscribe();
        participantsUnsubscribe = null;
    }
    if (matchesUnsubscribe) {
        matchesUnsubscribe();
        matchesUnsubscribe = null;
    }

    // 1. 참가자 목록 및 선택 현황 리스너
    const participantsRef = collection(db, 'artifacts', appId, 'public', 'data', 'participants');
    participantsUnsubscribe = onSnapshot(participantsRef, (snapshot) => {
        participants = [];
        submissions = {};
        snapshot.forEach(doc => {
            const data = doc.data();
            const id = doc.id;

            participants.push({ id: id, ...data });

            // 선택 현황 업데이트
            if (data.submitted) {
                submissions[id] = {
                    choice1: data.choice1, // Nickname String
                    choice2: data.choice2, // Nickname String
                    choice3: data.choice3, // Nickname String
                    nickname: data.nickname
                };
            }
        });

        // 닉네임 순으로 정렬 (UI 편의를 위해)
        participants.sort((a, b) => a.nickname.localeCompare(b.nickname));
        
        // 현재 사용자의 닉네임을 로컬 상태에 반영
        const user = participants.find(p => p.id === currentUserId);
        if (user) {
             currentUserNickname = user.nickname;
             document.getElementById('user-nickname').textContent = currentUserNickname;
        }

        // FIX: currentRole이 'none'이 아닐 때만 렌더링 함수 호출
        if (currentRole === 'participant') {
            // setupParticipant 내부에서 렌더링을 책임지도록 함
            setupParticipant(currentUserId); 
        } else if (currentRole === 'admin') {
            renderAdminView();
        }
    }, (error) => {
        console.error("참가자 목록 로드 오류:", error);
    });

    // 2. 최종 매칭 결과 리스너
    const matchesRef = collection(db, 'artifacts', appId, 'public', 'data', 'matches');
     matchesUnsubscribe = onSnapshot(matchesRef, (snapshot) => {
        if (!snapshot.empty) {
            // 최신 결과 하나만 사용
            const latestMatch = snapshot.docs[0].data();
            finalMatches = latestMatch.result || [];
        } else {
            finalMatches = [];
        }

        // 매칭 결과가 업데이트되면 참가자 모드와 관리자 모드를 모두 업데이트
        if (currentRole === 'participant') {
            setupParticipant(currentUserId); // 그대로 유지하여 UI를 업데이트
        } else if (currentRole === 'admin') {
            renderAdminView();
        }

    }, (error) => {
        console.error("매칭 결과 로드 오류:", error);
    });
}

// --------------------------------------------------------
// 3. 역할 및 UI 렌더링 (보안 강화)
// --------------------------------------------------------

/**
 * 관리자 모드 버튼 클릭 처리: 비밀번호 검증 필요
 */
function handleAdminClick() {
    if (isAdminValidated) {
        setRole('admin');
    } else {
        showAdminKeyInput();
    }
}

/**
 * 관리자 비밀번호 입력 폼 렌더링
 */
function showAdminKeyInput() {
    currentRole = 'none'; // 일시적으로 역할 해제
    const container = document.getElementById('mode-container');

    // 버튼 스타일 업데이트
    document.getElementById('btn-participant').classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700');
    document.getElementById('btn-participant').classList.add('bg-gray-100', 'text-gray-600', 'hover:bg-gray-200');
    document.getElementById('btn-admin').classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700');
    
    container.innerHTML = `
        <div class="max-w-md mx-auto p-8 bg-yellow-50 rounded-xl shadow-lg border border-yellow-200 mt-6">
            <h2 class="text-2xl font-bold text-yellow-800 mb-4 flex items-center justify-center">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
                관리자 비밀번호 입력
            </h2>
            <p class="text-sm text-gray-600 mb-4 text-center">매칭 기능을 사용하려면 비밀번호를 입력해주세요.</p>
            <input type="password" id="admin-key-input" placeholder="비밀번호를 입력하세요" class="w-full p-3 border border-yellow-300 rounded-lg focus:ring-yellow-500 focus:border-yellow-500 mb-4 text-center">
            <button onclick="checkAdminKeyAndProceed()" class="w-full py-3 text-white font-bold rounded-lg bg-yellow-600 hover:bg-yellow-700 transition shadow-md">
                관리자 모드 진입
            </button>
            <p id="admin-key-error" class="text-red-500 text-sm mt-3 text-center hidden">비밀번호가 일치하지 않습니다. (힌트: ${ADMIN_KEY})</p>
        </div>
    `;

    document.getElementById('admin-key-input').focus();
    document.getElementById('admin-key-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            checkAdminKeyAndProceed();
        }
    });
}

/**
 * 입력된 비밀번호를 확인하고 통과하면 관리자 모드로 진입
 */
function checkAdminKeyAndProceed() {
    const inputElement = document.getElementById('admin-key-input');
    const errorElement = document.getElementById('admin-key-error');

    if (!inputElement) return;

    const input = inputElement.value;

    if (input === ADMIN_KEY) {
        isAdminValidated = true;
        setRole('admin'); // 검증 성공 후 관리자 모드 렌더링
    } else {
        errorElement.textContent = "비밀번호가 일치하지 않습니다. 다시 시도해 주세요.";
        errorElement.classList.remove('hidden');
        inputElement.value = ''; // 입력값 초기화
        inputElement.focus();
    }
}

/**
 * 사용자 역할 설정 및 UI 업데이트
 * @param {string} role 'participant' 또는 'admin'
 */
function setRole(role) {
    // 버튼 스타일 업데이트
    document.getElementById('btn-participant').classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700', 'bg-gray-100', 'text-gray-600', 'hover:bg-gray-200');
    document.getElementById('btn-admin').classList.remove('bg-blue-600', 'text-white', 'hover:bg-blue-700', 'bg-gray-100', 'text-gray-600', 'hover:bg-gray-200');
    
    if (role === 'participant') {
        document.getElementById('btn-participant').classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700');
        document.getElementById('btn-admin').classList.add('bg-gray-100', 'text-gray-600', 'hover:bg-gray-200');
        currentRole = role;
        // 참가자 모드 진입 시 닉네임 설정 여부 확인
        setupParticipant(currentUserId); 
    } else if (role === 'admin') {
        // 관리자 모드 진입 시에는 반드시 isAdminValidated가 true여야 함
        if (!isAdminValidated) {
            handleAdminClick(); // 다시 비밀번호 입력 화면으로 유도
            return;
        }
        document.getElementById('btn-admin').classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700');
        document.getElementById('btn-participant').classList.add('bg-gray-100', 'text-gray-600', 'hover:bg-gray-200');
        currentRole = role;
        renderAdminView();
    }
}

/**
 * 참가자 모드 UI 렌더링
 */
function renderParticipantView() {
    const container = document.getElementById('mode-container');
    const user = participants.find(p => p.id === currentUserId);
    const userNickname = user ? user.nickname : currentUserNickname;
    const nicknamePattern = /^(햇님반|달님반)\s\d{2}\s.+$/;

    // 1. 닉네임 설정이 안 되었으면 폼을 보여주고 종료
    if (!nicknamePattern.test(userNickname)) {
         renderSetupForm();
         return;
    }

    // 2. 최종 매칭 결과 표시
    if (user && user.finalMatch) {
        // finalMatch는 상대방 ID 혹은 '솔로' 문자열
        const matchNickname = user.finalMatch === '솔로' ? '솔로' : (participants.find(p => p.id === user.finalMatch)?.nickname || '알 수 없음');
        container.innerHTML = `
            <div class="text-center p-8 bg-pink-50 border-4 border-pink-300 rounded-xl shadow-inner">
                <h2 class="text-2xl font-bold text-pink-700 mb-4">🎉 최종 선택 결과 🎉</h2>
                <p class="text-3xl font-extrabold ${matchNickname === '솔로' ? 'text-gray-500' : 'text-pink-600'}">
                    ${matchNickname === '솔로' ? '😭 솔로입니다 😭' : `매칭 상대: ${matchNickname}`}
                </p>
            </div>
            <p class="text-center text-sm text-gray-500 mt-4">매칭 결과는 관리자가 확정하면 표시됩니다.</p>
        `;
        return;
    }

    // 3. 선택 폼 표시 및 상대 그룹 필터링 (FULL_PARTICIPANT_LIST 기준)
    
    // 사용자의 그룹을 파악하여 상대 그룹을 결정
    const userClass = userNickname.split(' ')[0];
    const opponentClass = userClass === '햇님반' ? '달님반' : '햇님반';

    // FULL_PARTICIPANT_LIST에서 상대 그룹의 닉네임 전체를 가져옴
    const potentialOpponents = FULL_PARTICIPANT_LIST
        .filter(p => p.class === opponentClass)
        .map(p => `${p.class} ${p.num} ${p.name}`)
        .sort(); // 닉네임 순으로 정렬

    const isSubmitted = user ? user.submitted : false;

    // 선택 옵션은 Nickname String을 value로 가집니다. (UID가 아님)
    const selectionOptions = potentialOpponents.map(nickname =>
        `<option value="${nickname}">${nickname}</option>`
    ).join('');

    // 선택 옵션이 3개 미만일 경우는 참가자 리스트 설정 오류이므로, 여기서는 별도 경고 없이 진행
    // (FULL_PARTICIPANT_LIST는 16명이 보장되므로)

    const submissionStatusHtml = isSubmitted ?
        `<p class="text-center text-green-600 font-semibold mb-6 p-3 bg-green-50 rounded-lg">✅ 선택 제출 완료! (관리자의 매칭을 기다리고 있습니다.)</p>` :
        `<p class="text-center text-red-600 font-semibold mb-6 p-3 bg-red-50 rounded-lg">🚨 아직 선택을 제출하지 않았습니다.</p>`;

    container.innerHTML = `
        <h2 class="text-2xl font-bold text-gray-800 mb-6">나의 최종 선택 (${opponentClass} 중 3지망까지)</h2>
        ${submissionStatusHtml}
        <form id="selection-form" onsubmit="submitChoices(event)" class="space-y-4">
            <div class="flex flex-col space-y-2">
                <label for="choice1" class="font-semibold text-gray-700">1지망 (가장 중요!)</label>
                <select id="choice1" required ${isSubmitted ? 'disabled' : ''} class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="">-- ${opponentClass} 참가자 중 선택하세요 --</option>
                    ${selectionOptions}
                </select>
            </div>
            <div class="flex flex-col space-y-2">
                <label for="choice2" class="font-semibold text-gray-700">2지망</label>
                <select id="choice2" required ${isSubmitted ? 'disabled' : ''} class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="">-- ${opponentClass} 참가자 중 선택하세요 --</option>
                    ${selectionOptions}
                </select>
            </div>
            <div class="flex flex-col space-y-2">
                <label for="choice3" class="font-semibold text-gray-700">3지망</label>
                <select id="choice3" required ${isSubmitted ? 'disabled' : ''} class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="">-- ${opponentClass} 참가자 중 선택하세요 --</option>
                    ${selectionOptions}
                </select>
            </div>

            <button type="submit" ${isSubmitted ? 'disabled' : ''} class="w-full py-3 mt-6 text-white font-bold rounded-lg transition duration-150 ${isSubmitted ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 active:bg-blue-800 shadow-md hover:shadow-lg'}">
                ${isSubmitted ? '제출 완료됨' : '선택 제출하기'}
            </button>
        </form>
    `;

    // 기존 선택 값 로드 (이제 Nickname String을 로드)
    if (user) {
        document.getElementById('choice1').value = user.choice1 || '';
        document.getElementById('choice2').value = user.choice2 || '';
        document.getElementById('choice3').value = user.choice3 || '';
    }
}

/**
 * 관리자 모드 UI 렌더링
 */
function renderAdminView() {
    // isAdminValidated 검사를 setRole에서 이미 했으므로 여기서는 렌더링만 수행
    const container = document.getElementById('mode-container');
    const total = participants.length;
    const submitted = Object.keys(submissions).length;
    const remaining = FULL_PARTICIPANT_LIST.length - submitted; // 전체 참가자 32명 기준으로 미제출 계산

    // 참가자 선택 현황 테이블
    const submissionRows = participants.map(p => {
        const isSubmitted = p.submitted;
        const matchId = p.finalMatch;
        const matchNickname = matchId === '솔로' ? '솔로' : (participants.find(pt => pt.id === matchId)?.nickname || '-');

        let matchClass = 'text-gray-500';
        if (matchId && matchId !== '솔로') matchClass = 'text-pink-600 font-bold';
        else if (matchId === '솔로') matchClass = 'text-gray-400';

        // 선택 지망 표시 시 상대방 닉네임 문자열(choice1, 2, 3)을 그대로 사용
        const getChoiceDisplay = (choice) => choice || '-';

        return `
            <tr class="border-b transition duration-150 hover:bg-gray-50">
                <td class="p-3 font-semibold text-gray-900">${p.nickname}</td>
                <td class="p-3 text-center">
                    <span class="inline-block px-3 py-1 text-xs font-medium rounded-full ${isSubmitted ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}">
                        ${isSubmitted ? 'O' : 'X'}
                    </span>
                </td>
                <td class="p-3 hidden sm:table-cell text-sm text-gray-700">${isSubmitted ? `1: ${getChoiceDisplay(p.choice1)}, 2: ${getChoiceDisplay(p.choice2)}, 3: ${getChoiceDisplay(p.choice3)}` : '-'}</td>
                <td class="p-3 text-center ${matchClass}">${matchNickname}</td>
            </tr>
        `;
    }).join('');

    // 최종 매칭 결과 리스트
    const matchedPairsHtml = finalMatches.length > 0 ?
        finalMatches.map(pair => {
            const p1Name = participants.find(p => p.id === pair.p1)?.nickname || pair.p1;
            const p2Name = participants.find(p => p.id === pair.p2)?.nickname || pair.p2;
            let matchType = '';
            if (pair.type === 1) matchType = `<span class="text-red-500 font-bold">(1지망 상호)</span>`;
            else if (pair.type === 2) matchType = `<span class="text-blue-500 font-bold">(1-3지망 상호)</span>`;

            return `<li class="p-3 bg-pink-50 rounded-lg flex justify-between items-center shadow-sm">
                        <span class="font-bold text-gray-800">${p1Name} & ${p2Name}</span>
                        ${matchType}
                    </li>`;
        }).join('') :
        '<li class="p-4 text-center text-gray-500 bg-gray-50 rounded-lg">아직 매칭 결과가 없습니다.</li>';
    
    // 미제출 인원 경고 텍스트 (전체 32명 중 현재 닉네임을 등록하고 제출한 인원 기준)
    const submissionWarning = FULL_PARTICIPANT_LIST.length > total ? 
        `<p class="text-xs text-red-500 mt-1"> * 32명 중 닉네임을 등록하지 않은 참가자 ${FULL_PARTICIPANT_LIST.length - total}명이 제외된 ${total}명의 제출 현황입니다.</p>` : '';


    container.innerHTML = `
        <h2 class="text-2xl font-bold text-gray-800 mb-4">관리자 대시보드</h2>

        <div class="grid grid-cols-3 gap-4 mb-8">
            <div class="bg-blue-50 p-4 rounded-lg text-center shadow">
                <p class="text-sm text-blue-600 font-medium">전체 참가자</p>
                <p class="text-2xl font-extrabold text-blue-800">32명</p>
            </div>
            <div class="bg-green-50 p-4 rounded-lg text-center shadow">
                <p class="text-sm text-green-600 font-medium">제출 완료</p>
                <p class="text-2xl font-extrabold text-green-800">${submitted}명</p>
            </div>
            <div class="bg-yellow-50 p-4 rounded-lg text-center shadow">
                <p class="text-sm text-yellow-600 font-medium">미제출 (닉네임 등록 기준)</p>
                <p class="text-2xl font-extrabold text-yellow-800">${total - submitted}명</p>
            </div>
        </div>

        <div class="mb-8">
            <button onclick="runMatchingAlgorithm()" ${total !== FULL_PARTICIPANT_LIST.length || remaining > 0 || isMatchInProgress ? 'disabled' : ''} class="w-full py-4 text-white font-bold rounded-xl text-xl transition duration-150 ${total !== FULL_PARTICIPANT_LIST.length || remaining > 0 ? 'bg-red-400 cursor-not-allowed' : (isMatchInProgress ? 'bg-gray-400' : 'bg-pink-600 hover:bg-pink-700 active:bg-pink-800 shadow-lg')}">
                ${isMatchInProgress ? '매칭 계산 중...' : (total !== FULL_PARTICIPANT_LIST.length ? '🚨 전체 32명 닉네임 등록 완료 필요' : (remaining > 0 ? `🚨 ${remaining}명 미제출! 매칭 불가` : '💖 최종 매칭 자동화 실행'))}
            </button>
            ${submissionWarning}
        </div>

        <h3 class="text-xl font-bold text-gray-800 mb-3 border-t pt-6">결과: 매칭된 커플 (${finalMatches.length}쌍)</h3>
        <ul class="space-y-3 mb-8">
            ${matchedPairsHtml}
        </ul>

        <h3 class="text-xl font-bold text-gray-800 mb-3 border-t pt-6">참가자별 선택 및 매칭 현황</h3>
        <div class="overflow-x-auto bg-gray-50 rounded-xl shadow-inner">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="p-3 text-left text-xs font-bold text-gray-600 uppercase tracking-wider">닉네임</th>
                        <th class="p-3 text-center text-xs font-bold text-gray-600 uppercase tracking-wider">제출</th>
                        <th class="p-3 hidden sm:table-cell text-left text-xs font-bold text-gray-600 uppercase tracking-wider">선택 지망 (1, 2, 3)</th>
                        <th class="p-3 text-center text-xs font-bold text-gray-600 uppercase tracking-wider">최종 매칭</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                    ${submissionRows}
                </tbody>
            </table>
        </div>

        <div class="mt-8 p-4 bg-gray-100 rounded-lg text-sm text-gray-600">
            <p class="font-bold mb-1">📢 매칭 규칙 요약:</p>
            <ul class="list-disc list-inside space-y-1">
                <li>1순위: 상호 1지망 매칭 (우선 처리)</li>
                <li>2순위: 1순위에서 제외된 인원 중, 상호 1~3지망 매칭</li>
                <li>매칭된 인원은 다음 매칭 순서에서 자동 제외됩니다.</li>
            </ul>
        </div>
    `;
}

// --------------------------------------------------------
// 4. 참가자 선택 제출
// --------------------------------------------------------
async function submitChoices(event) {
    event.preventDefault();
    const form = event.target;
    const choice1 = form.choice1.value; // Nickname String
    const choice2 = form.choice2.value; // Nickname String
    const choice3 = form.choice3.value; // Nickname String

    // 중복 선택 검증
    const choices = [choice1, choice2, choice3];
    const uniqueChoices = new Set(choices);
    if (choices.length !== uniqueChoices.size) {
        showModal('1지망, 2지망, 3지망은 서로 다른 상대를 선택해야 합니다.', false);
        return;
    }

    // Nickname은 현재 로그인한 사용자의 닉네임과 다를 것이므로, self-selection check는 필요 없음

    showModal('선택 정보를 제출하는 중...', true);

    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'participants', currentUserId);

    try {
        // 이제 choice1, choice2, choice3 필드에는 상대방의 닉네임 문자열이 저장됩니다.
        await setDoc(docRef, {
            choice1: choice1,
            choice2: choice2,
            choice3: choice3,
            submitted: true,
        }, { merge: true });

        hideModal();
        showModal('✅ 선택 제출이 완료되었습니다!', false);
        renderParticipantView(); // UI 즉시 업데이트
    } catch (e) {
        console.error("선택 제출 오류:", e);
        showModal(`제출 실패: ${e.message}`, false);
    }
}

// --------------------------------------------------------
// 5. 핵심: 매칭 알고리즘 (관리자 실행)
// --------------------------------------------------------

/**
 * 최종 매칭 알고리즘 실행
 */
async function runMatchingAlgorithm() {
    if (isMatchInProgress) return;
    
    // 보안 검증 (클라이언트 UI로만 접근 가능하도록 처리하지만, 함수 호출 시에도 플래그 확인)
    if (!isAdminValidated) {
        showModal('🚨 관리자 인증이 필요합니다. 다시 비밀번호를 입력해주세요.', false);
        return;
    }
    
    // 모든 32명이 닉네임 등록 및 제출을 완료했는지 최종 확인
    const totalParticipantsRegistered = participants.length;
    const totalParticipantsSubmitted = Object.keys(submissions).length;

    if (totalParticipantsRegistered !== FULL_PARTICIPANT_LIST.length) {
        showModal(`🚨 전체 32명 중 ${FULL_PARTICIPANT_LIST.length - totalParticipantsRegistered}명이 아직 닉네임을 등록하지 않았습니다. 매칭을 실행할 수 없습니다.`, false);
        return;
    }
    if (totalParticipantsSubmitted !== FULL_PARTICIPANT_LIST.length) {
        showModal(`🚨 전체 32명 중 ${FULL_PARTICIPANT_LIST.length - totalParticipantsSubmitted}명이 아직 선택을 제출하지 않았습니다. 매칭을 실행할 수 없습니다.`, false);
        return;
    }


    isMatchInProgress = true;
    showModal('💖 최종 매칭 알고리즘을 실행합니다...', true);

    // 매칭을 위해 모든 참가자 데이터와 선택 정보를 가져옴 (실시간 데이터 활용)
    const allParticipants = participants; // 닉네임 등록을 완료한 32명
    const matches = [];
    const matchedIds = new Set();
    
    // ID <-> 데이터 맵 (P1의 ID 찾기용)
    const participantDataMap = new Map();
    allParticipants.forEach(p => participantDataMap.set(p.id, p));

    // Nickname <-> ID 맵 (P1이 선택한 닉네임의 ID 찾기용)
    const participantIdByNickname = new Map();
    allParticipants.forEach(p => participantIdByNickname.set(p.nickname, p.id));


    // -------------------------
    // Phase 1: 상호 1지망 매칭 (우선 매칭)
    // -------------------------
    for (const p1 of allParticipants) {
        if (matchedIds.has(p1.id)) continue; 
        if (!p1.submitted) continue; // 제출하지 않은 사람은 매칭 대상에서 제외

        const p2Nickname = p1.choice1;
        
        // p1이 선택한 상대방(p2)이 닉네임 등록을 완료했는지 확인
        const p2Id = participantIdByNickname.get(p2Nickname);
        const p2 = participantDataMap.get(p2Id);

        if (!p2 || matchedIds.has(p2Id) || !p2.submitted) continue; // 상대방 미등록/이미 매칭/미제출 시 제외

        // 상호 1지망 확인: P2의 1지망 닉네임이 P1의 닉네임과 일치하는가?
        if (p2.choice1 === p1.nickname) { 
            matches.push({ p1: p1.id, p2: p2Id, type: 1 }); // type 1: 1지망 매칭
            matchedIds.add(p1.id);
            matchedIds.add(p2Id);
        }
    }
    console.log(`Phase 1 완료: 상호 1지망 매칭 ${matches.length}쌍`);

    // -------------------------
    // Phase 2: 상호 1~3지망 매칭 (차순 매칭)
    // -------------------------
    for (const p1 of allParticipants) {
        if (matchedIds.has(p1.id)) continue; 
        if (!p1.submitted) continue;

        const p1ChoicesNicknames = [p1.choice1, p1.choice2, p1.choice3];

        for (const p2Nickname of p1ChoicesNicknames) {
            // P1이 선택한 상대방(p2)이 닉네임 등록을 완료했는지 확인
            const p2Id = participantIdByNickname.get(p2Nickname);
            if (!p2Id || matchedIds.has(p2Id)) continue; 

            const p2 = participantDataMap.get(p2Id);
            if (!p2 || !p2.submitted) continue; // 상대방 미등록/미제출 시 제외

            const p2ChoicesNicknames = [p2.choice1, p2.choice2, p2.choice3];

            // P2가 P1을 1~3지망 이내에 선택했는지 확인 (P1의 닉네임 사용)
            if (p2ChoicesNicknames.includes(p1.nickname)) {
                matches.push({ p1: p1.id, p2: p2Id, type: 2 }); // type 2: 1~3지망 매칭
                matchedIds.add(p1.id);
                matchedIds.add(p2Id);
                break; // P1의 매칭이 성공했으므로 다음 참가자로 넘어감
            }
        }
    }
    console.log(`Phase 2 완료: 최종 매칭 ${matches.length}쌍`);

    // -------------------------
    // 3. Firestore에 최종 결과 저장 및 참가자 데이터 업데이트
    // -------------------------
    const batch = writeBatch(db);
    const allMatchIds = new Set(matches.flatMap(m => [m.p1, m.p2]));

    try {
        // 매칭 결과 문서 저장 (가장 최신 결과만 남기기 위해 항상 동일한 ID 사용)
        const matchResultRef = doc(db, 'artifacts', appId, 'public', 'data', 'matches', 'latestResult');
        batch.set(matchResultRef, {
            result: matches,
            timestamp: Date.now(),
            totalMatches: matches.length
        });

        // 각 참가자 문서 업데이트
        allParticipants.forEach(p => {
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'participants', p.id);
            let finalMatchId = '솔로'; // 기본값은 솔로

            // 매칭된 짝을 찾음
            for (const match of matches) {
                if (match.p1 === p.id) {
                    finalMatchId = match.p2;
                    break;
                } else if (match.p2 === p.id) {
                    finalMatchId = match.p1;
                    break;
                }
            }

            batch.update(docRef, {
                finalMatch: finalMatchId // 솔로이거나 상대방 ID
            });
        });

        await batch.commit();

        hideModal();
        showModal(`✅ 최종 매칭 완료! 총 ${matches.length}쌍이 탄생했습니다.`, false);
        isMatchInProgress = false;
        renderAdminView(); // UI 즉시 업데이트

    } catch (e) {
        console.error("매칭 결과 저장 및 업데이트 오류:", e);
        showModal(`매칭 저장 실패: ${e.message}`, false);
        isMatchInProgress = false;
    }
}

// --------------------------------------------------------
// 6. 유틸리티 (모달)
// --------------------------------------------------------
function showModal(message, showSpinner) {
    document.getElementById('modal-message').textContent = message;
    document.getElementById('modal-backdrop').classList.remove('hidden');
    document.getElementById('modal-backdrop').classList.add('flex');

    if (showSpinner) {
        document.getElementById('modal-spinner').classList.remove('hidden');
        document.getElementById('modal-close-btn').classList.add('hidden');
    } else {
        document.getElementById('modal-spinner').classList.add('hidden');
        document.getElementById('modal-close-btn').classList.remove('hidden');
    }
}

function hideModal() {
    document.getElementById('modal-backdrop').classList.add('hidden');
    document.getElementById('modal-backdrop').classList.remove('flex');
}

// 전역 함수 노출 (HTML에서 호출 가능하도록)
window.setRole = setRole;
window.handleAdminClick = handleAdminClick; // 관리자 클릭 핸들러 노출
window.checkAdminKeyAndProceed = checkAdminKeyAndProceed; // 키 체크 함수 노출
window.submitSetupForm = submitSetupForm; // 닉네임 설정 폼 제출 함수 노출
window.updateCalculatedNickname = updateCalculatedNickname; // 닉네임 계산 함수 노출
window.submitChoices = submitChoices;
window.runMatchingAlgorithm = runMatchingAlgorithm;
window.hideModal = hideModal;

// 시작
initializeFirebase();
